---
title: –ú–∞—Å—Å–∏–≤—ã –¥–∞–Ω–Ω—ã—Ö –≤ JavaScript API Dataview
description: –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ —Ä–∞–±–æ—Ç–µ —Å –º–∞—Å—Å–∏–≤–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö –≤ JavaScript API Dataview
tags:
  - dataview
  - javascript
  - arrays
  - api
  - documentation
keywords:
  - –º–∞—Å—Å–∏–≤—ã –¥–∞–Ω–Ω—ã—Ö
  - javascript api
  - dataview
  - –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö
  - –º–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏ —Å –¥–∞–Ω–Ω—ã–º–∏
created: 2024-11-30
updated: 2024-12-15
category: Obsidian/Plugins/Dataview/JavaScript
source: https://blacksmithgu.github.io/obsidian-dataview/api/data-array/
author: blacksmithgu
language: ru
—á–µ—Ä–Ω–æ–≤–∏–∫: false
—Å—Ç–∞—Ç—É—Å: ‚úÖ –ì–æ—Ç–æ–≤–æ
–∞—Ä—Ö–∏–≤: false
---

# üìä –ú–∞—Å—Å–∏–≤—ã –¥–∞–Ω–Ω—ã—Ö –≤ Dataview

## –û—Å–Ω–æ–≤–Ω–æ–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

```table-of-contents
```

## –ú–∞—Å—Å–∏–≤—ã –¥–∞–Ω–Ω—ã—Ö

–û–±—â–µ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–æ–≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≤ Dataview ‚Äî —ç—Ç–æ `DataArray`, –∫–æ—Ç–æ—Ä—ã–π —è–≤–ª—è–µ—Ç—Å—è [–ø—Ä–æ–∫—Å–∏-](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) –≤–µ—Ä—Å–∏–µ–π –º–∞—Å—Å–∏–≤–∞ JavaScript —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å—é. –ú–∞—Å—Å–∏–≤—ã –¥–∞–Ω–Ω—ã—Ö –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—é –∏ –∏—Ç–µ—Ä–∞—Ü–∏—é (—á–µ—Ä–µ–∑ `for`–∏ `for ... of`—Ü–∏–∫–ª—ã), –∫–∞–∫ –∏ –æ–±—ã—á–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã, –Ω–æ —Ç–∞–∫–∂–µ –≤–∫–ª—é—á–∞—é—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ –º–∞–Ω–∏–ø—É–ª–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã–º–∏, —Ç–∞–∫–∏—Ö –∫–∞–∫ `sort`, `groupBy`, `distinct`, `where`, –∏ —Ç. –¥., —á—Ç–æ–±—ã —É–ø—Ä–æ—Å—Ç–∏—Ç—å –º–∞–Ω–∏–ø—É–ª–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–∞–±–ª–∏—á–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏.

## –°–æ–∑–¥–∞–Ω–∏–µ

–ú–∞—Å—Å–∏–≤—ã –¥–∞–Ω–Ω—ã—Ö –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ–º API Dataview, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤, –Ω–∞–ø—Ä–∏–º–µ—Ä `dv.pages()`. –í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ —è–≤–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –æ–±—ã—á–Ω—ã–π –º–∞—Å—Å–∏–≤ JavaScript –≤ –º–∞—Å—Å–∏–≤ Dataview, –∏—Å–ø–æ–ª—å–∑—É—è `dv.array(<array>)`. –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –º–∞—Å—Å–∏–≤ Data –æ–±—Ä–∞—Ç–Ω–æ –≤ –æ–±—ã—á–Ω—ã–π –º–∞—Å—Å–∏–≤, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ `DataArray#array()`.

## –ò–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —Å–≤–∏–∑–ª–∏–Ω–≥

–ú–∞—Å—Å–∏–≤—ã –¥–∞–Ω–Ω—ã—Ö –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –æ–±—ã—á–Ω—É—é –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—é, –∫–∞–∫ –∏ –æ–±—ã—á–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, `array[0]`), –Ω–æ, —á—Ç–æ –≤–∞–∂–Ω–æ, –æ–Ω–∏ —Ç–∞–∫–∂–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç ¬´–ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫—É¬ª –≤ —Å—Ç–∏–ª–µ —è–∑—ã–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤: –µ—Å–ª–∏ –≤—ã –∏–Ω–¥–µ–∫—Å–∏—Ä—É–µ—Ç–µ –º–∞—Å—Å–∏–≤ –¥–∞–Ω–Ω—ã—Ö —Å –∏–º–µ–Ω–µ–º –ø–æ–ª—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, `array.field`), –æ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–ø–æ—Å—Ç–∞–≤–ª—è–µ—Ç –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞ —Å `field`, –≤—ã–ø–æ–ª–Ω—è—è –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ, `field`–µ—Å–ª–∏ –æ–Ω —Å–∞–º —Ç–∞–∫–∂–µ —è–≤–ª—è–µ—Ç—Å—è –º–∞—Å—Å–∏–≤–æ–º.

–ù–∞–ø—Ä–∏–º–µ—Ä, `dv.pages().file.name`–≤–µ—Ä–Ω–µ—Ç –º–∞—Å—Å–∏–≤ –¥–∞–Ω–Ω—ã—Ö –≤—Å–µ—Ö –∏–º–µ–Ω —Ñ–∞–π–ª–æ–≤ –≤ –≤–∞—à–µ–º —Ö—Ä–∞–Ω–∏–ª–∏—â–µ; `dv.pages("#books").genres`–≤–µ—Ä–Ω–µ—Ç —Å–≥–ª–∞–∂–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∂–∞–Ω—Ä–æ–≤ –≤ –≤–∞—à–∏—Ö –∫–Ω–∏–≥–∞—Ö.

## –ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å

–ü–æ–ª–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –º–∞—Å—Å–∏–≤–∞ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏–≤–µ–¥–µ–Ω –Ω–∏–∂–µ –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏:

```
/** A function which maps an array element to some value. */
export type ArrayFunc<T, O> = (elem: T, index: number, arr: T[]) => O;

/** A function which compares two types. */
export type ArrayComparator<T> = (a: T, b: T) => number;

/**
 * Proxied interface which allows manipulating array-based data. All functions on a data array produce a NEW array
 * (i.e., the arrays are immutable).
 */
export interface DataArray<T> {
    /** The total number of elements in the array. */
    length: number;

    /** Filter the data array down to just elements which match the given predicate. */
    where(predicate: ArrayFunc<T, boolean>): DataArray<T>;
    /** Alias for 'where' for people who want array semantics. */
    filter(predicate: ArrayFunc<T, boolean>): DataArray<T>;

    /** Map elements in the data array by applying a function to each. */
    map<U>(f: ArrayFunc<T, U>): DataArray<U>;
    /** Map elements in the data array by applying a function to each, then flatten the results to produce a new array. */
    flatMap<U>(f: ArrayFunc<T, U[]>): DataArray<U>;
    /** Mutably change each value in the array, returning the same array which you can further chain off of. */
    mutate(f: ArrayFunc<T, any>): DataArray<any>;

    /** Limit the total number of entries in the array to the given value. */
    limit(count: number): DataArray<T>;
    /**
     * Take a slice of the array. If \`start\` is undefined, it is assumed to be 0; if \`end\` is undefined, it is assumed
     * to be the end of the array.
     */
    slice(start?: number, end?: number): DataArray<T>;
    /** Concatenate the values in this data array with those of another iterable / data array / array. */
    concat(other: Iterable<T>): DataArray<T>;

    /** Return the first index of the given (optionally starting the search) */
    indexOf(element: T, fromIndex?: number): number;
    /** Return the first element that satisfies the given predicate. */
    find(pred: ArrayFunc<T, boolean>): T | undefined;
    /** Find the index of the first element that satisfies the given predicate. Returns -1 if nothing was found. */
    findIndex(pred: ArrayFunc<T, boolean>, fromIndex?: number): number;
    /** Returns true if the array contains the given element, and false otherwise. */
    includes(element: T): boolean;

    /**
     * Return a string obtained by converting each element in the array to a string, and joining it with the
     * given separator (which defaults to ', ').
     */
    join(sep?: string): string;

    /**
     * Return a sorted array sorted by the given key; an optional comparator can be provided, which will
     * be used to compare the keys in leiu of the default dataview comparator.
     */
    sort<U>(key: ArrayFunc<T, U>, direction?: "asc" | "desc", comparator?: ArrayComparator<U>): DataArray<T>;

    /**
     * Return an array where elements are grouped by the given key; the resulting array will have objects of the form
     * { key: <key value>, rows: DataArray }.
     */
    groupBy<U>(key: ArrayFunc<T, U>, comparator?: ArrayComparator<U>): DataArray<{ key: U; rows: DataArray<T> }>;

    /**
     * Return distinct entries. If a key is provided, then rows with distinct keys are returned.
     */
    distinct<U>(key?: ArrayFunc<T, U>, comparator?: ArrayComparator<U>): DataArray<T>;

    /** Return true if the predicate is true for all values. */
    every(f: ArrayFunc<T, boolean>): boolean;
    /** Return true if the predicate is true for at least one value. */
    some(f: ArrayFunc<T, boolean>): boolean;
    /** Return true if the predicate is FALSE for all values. */
    none(f: ArrayFunc<T, boolean>): boolean;

    /** Return the first element in the data array. Returns undefined if the array is empty. */
    first(): T;
    /** Return the last element in the data array. Returns undefined if the array is empty. */
    last(): T;

    /** Map every element in this data array to the given key, and then flatten it.*/
    to(key: string): DataArray<any>;
    /**
     * Recursively expand the given key, flattening a tree structure based on the key into a flat array. Useful for handling
     * hierarchical data like tasks with 'subtasks'.
     */
    expand(key: string): DataArray<any>;

    /** Run a lambda on each element in the array. */
    forEach(f: ArrayFunc<T, void>): void;

    /** Calculate the sum of the elements in the array. */
    sum(): number;

    /** Calculate the average of the elements in the array. */
    avg(): number;

    /** Calculate the minimum of the elements in the array. */
    min(): number;

    /** Calculate the maximum of the elements in the array. */
    max(): number;

    /** Convert this to a plain javascript array. */
    array(): T[];

    /** Allow iterating directly over the array. */
    [Symbol.iterator](): Iterator<T>;

    /** Map indexes to values. */
    [index: number]: any;
    /** Automatic flattening of fields. Equivalent to implicitly calling \`array.to("field")\` */
    [field: string]: any;
}
```

–Ø–∑—ã–∫ —ç—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã: –ê–Ω–≥–ª–∏–π—Å–∫–∏–π

–í—Å–µ–≥–¥–∞ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å –ê–Ω–≥–ª–∏–π—Å–∫–∏–π –Ω–∞ –†—É—Å—Å–∫–∏–π  
–ù–∏–∫–æ–≥–¥–∞ –Ω–µ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å –ê–Ω–≥–ª–∏–π—Å–∫–∏–π  
–ù–∏–∫–æ–≥–¥–∞ –Ω–µ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å blacksmithgu.github.io